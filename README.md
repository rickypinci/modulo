# Modular Extra-functional Analysis of Software Architectural Design Models

This is the replication package of the paper titled "Modular Extra-functional Analysis of Software Architectural Design Models" and submitted for revision to ECSA 2022.


## Abstract
Emerging applications such as collaborative and autonomous cyber-physical systems seek for innovative techniques that support extra-functional analysis as key concern to be considered.
The objective of this paper is to complement software architectural design models with a set of *modules* that are (i) representative of multiple extra-functional properties, and (ii) equipped with strategies aimed to establish rules of interaction among them in a feedback loop fashion.
We propose a novel methodology that builds upon the specification of extra-functional modules and enables the generation of design alternatives as outcome of an internal intertwining of different extra-functional analysis results.
A case study in the domain of a collaborative and autonomous network of sensors is presented, and experimental results show that software architects are supported in the selection of design alternatives by quantitative information. A comparison with an integrated model is performed, and we demonstrate the advantages of such a modular analysis.


## Available Files
- <tt>images/</tt> contains all figures presented in the paper.
- <tt>implementation/</tt> contains scripts and code of *MUTUAL*.
	- <tt>analysis.ipynb</tt>, the notebook that plots all figures in the paper starting from data generated by *MUTUAL*.
	- <tt>battery\_kibam.py</tt>, an implementation of the Kinetic Battery Model by Julius Susanto ([download](https://github.com/susantoj/kinetic-battery))
	- <tt>module\_battery.py</tt>, new models of the *Battery Depletion* module should be deployed here.
	- <tt>module\_performance.py</tt>, new models of the *System Performance* module should be deployed here.
	- <tt>module\_reward.py</tt>, new models if the *Reward Computation* module should be deployed here.
	- <tt>mvaApprox\_octave.m</tt>, an implementation of the Approximate MVA in Octave, using the *queueing* package.
	- <tt>mva\_octave.m</tt>, an implementation of the MVA in Octave, using the *queueing* package.
	- <tt>params.py</tt>, this file contains input parameters of all modules (as reported in Table 1 of the paper). Please, change this file to test our *MUTUAL* implementation with different numerical values.
	- <tt>profiles.py</tt>, this file contains all system configurations (as reported in Table 2 of the paper). Please, change this file to test our *MUTUAL* implementation with different configurations.
	- <tt>runMUTUAL.py</tt>, the file orchestrating all modules. Please, run <tt>python3 runModules.py \<output\_file\></tt> to test our *MUTUAL* implementation.
- <tt>QPN\_simulation/</tt> contains the QPN (<tt>integrated.jsimg</tt>) to simulate using the *Java Modelling Tools* and data (<tt>sim\_results.ods</tt>) collected from our simulation.
- <tt>results/</tt> contains data generated from *MUTUAL*. The name of files containing results follows the pattern: <tt>results\<ID\>\_\<config\></tt>, where:
	- \<ID\> goes from 7 to 10 and represents the module deplyment. Specifically:
		- 7 = Linear + MVA + W/O
		- 8 = KiBaM + MVA + W/O
		- 9 = KiBaM + AMVA + W/O
		- 10 = KiBaM + AMVA + W/
	- \<config\> is the chosen configuration. It is <tt>mix</tt> if the number of customers and cores varies with the battery state of charge, it is <tt>fix\_\<N1\>\_\<N2\></tt> if the system state is fixed at the beginning of the analysis, with the number of low- and high-quality requests set to *N1* and *N2*, respectively.


## Requirements
- Python3, to run the *MUTUAL* infrastructure.
- Required Python modules are in <tt>requirements.txt</tt>. Please, run <tt>pip3 install -r requirements.txt</tt> to install all those modules.
- Octave and the [queueing](https://octave.sourceforge.io/queueing/index.html) package, to run the (Approximate) MVA solution used in the *System Performance* module.
- [Java Modelling Tools](http://jmt.sourceforge.net/), to run the *Queuing Petri Net* model used for evaluation.


## Run *MUTUAL*
- To run our *MUTUAL* implementation, please run <tt>python3 runMUTUAL.py \<output\_file\></tt>. Currently, KiBaM, Approximate MVA, and Reward With Penalty are the models/solutions used for the three modules. Input parameters are those presented in Table 1 of the paper. <tt>\<output\_file\></tt> must be a CSV file where *MUTUAL* saves generated data.
- To test different models (among those already implemented, i.e., Linear Battery, MVA, or Reward Without Penalty) open the <tt>runMUTUAL.py</tt> file. Here, (un)comment lines 103-104 (*System Perfomance* module), 114-115 (*Battery Depletion* module), and 123-124 (*Reward Computation* module).
- To deploy an existing module with a new model, add the new model in the relative file (<tt>module\_battery.py</tt>, <tt>module\_performance.py</tt>, or <tt>module\_reward.py</tt> as described in the [Available Files](#available-files) section of this README).
- To add a new module to our *MUTUAL* implementation:
	1) Create the new module (e.g., <tt>module\_new.py</tt>).
	2) Open the <tt>runMUTUAL.py</tt> file and import the new module with <tt>from module\_new.py import \*</tt>.
	3) Implement the new system logic by adding the new module to the *While* loop (lines 94-135) so that it can interact with other modules.
	4) If needed, you can add new input parameters in <tt>params.py</tt>.
