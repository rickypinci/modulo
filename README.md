# Modular Extra-functional Analysis of Software Architectural Design Models

This is the replication package of the paper titled "Modular Extra-functional Analysis of Software Architectural Design Models" and submitted for revision to ECSA 2022.


## Abstract
Emerging applications such as collaborative and autonomous cyber-physical systems seek for innovative techniques that support extra-functional analysis as key concern to be considered.
The objective of this paper is to complement software architectural design models with a set of *modules* that are (i) representative of multiple extra-functional properties, and (ii) equipped with strategies aimed to establish rules of interaction among them in a feedback loop fashion.
We propose a novel methodology that builds upon the specification of extra-functional modules and enables the generation of design alternatives as outcome of an internal intertwining of different extra-functional analysis results.
A case study in the domain of a collaborative and autonomous network of sensors is presented, and experimental results show that software architects are supported in the selection of design alternatives by quantitative information. A comparison with an integrated model is performed, and we demonstrate the advantages of such a modular analysis.


## Available Files
- <tt>images/</tt> contains all figures presented in the paper.
- <tt>implementation/</tt> contains scripts and code of *MUTUAL*.
	- <tt>analysis.ipynb</tt>, the notebook that plots all figures in the paper starting from data generated by *MUTUAL*.
	- <tt>battery\_kibam.py</tt>, an implementation of the Kinetic Battery Model by Julius Susanto ([download](https://github.com/susantoj/kinetic-battery))
	- <tt>module\_battery.py</tt>, new models of the *Battery Depletion* module should be deployed here.
	- <tt>module\_performance.py</tt>, new models of the *System Performance* module should be deployed here.
	- <tt>module\_reward.py</tt>, new models if the *Reward Computation* module should be deployed here.
	- <tt>mvaApprox\_octave.m</tt>, an implementation of the Approximate MVA in Octave, using the *queueing* package.
	- <tt>mva\_octave.m</tt>, an implementation of the MVA in Octave, using the *queueing* package.
	- <tt>params.py</tt>, this file contains input parameters of all modules (as reported in Table 1 of the paper). Please, change this file to test our *MUTUAL* implementation with different numerical values.
	- <tt>profiles.py</tt>, this file contains all system configurations (as reported in Table 2 of the paper). Please, change this file to test our *MUTUAL* implementation with different configurations.
	- <tt>runMUTUAL.py</tt>, the file orchestrating all modules. Please, run <tt>python3 runModules.py \<output\_file\></tt> to test our *MUTUAL* implementation.
- <tt>QPN\_simulation/</tt> contains the QPN (<tt>integrated.jsimg</tt>) to simulate using the *Java Modelling Tools* and data (<tt>sim\_results.ods</tt>) collected from our simulation.
- <tt>results/</tt> contains data generated from *MUTUAL*.
	- filename strucuture TODO


## Requirements
- Python3, to run the *MUTUAL* infrastructure.
- Required Python modules are in <tt>requirements.txt</tt>. Please, run <tt>pip3 install -r requirements.txt</tt> to install all those modules.
- Octave and the [queueing](https://octave.sourceforge.io/queueing/index.html) package, to run the (Approximate) MVA solution used in the *System Performance* module.
- [Java Modelling Tools](http://jmt.sourceforge.net/), to run the *Queuing Petri Net* model used for evaluation.


## Run *MUTUAL*
1) To run our *MUTUAL* implementation, please run <tt>python3 runMUTUAL.py \<output\_file\></tt>. Currently, KiBaM, Approximate MVA, and Reward With Penalty are the models/solutions used for the three modules. Input parameters are those presented in Table 1 of the paper. <tt>output_file</tt> must be a CSV file where *MUTUAL* saves generated data.
